
// ============================
// EXPORT CLOZE FOR MOODLE
// HTML and moodle cloze format
// ============================

function getTreeSvg() {
  let svg = document.getElementById('svgDT');

  // Fallbacks
  if (!svg || svg.tagName.toLowerCase() !== 'svg') {
    svg = document.querySelector('#svgDT svg') ||
          document.querySelector('#treeContainer svg') ||
          document.querySelector('svg');
  }

  if (!svg) {
    alert('The SVG for the tree was not found. Has the tree already been built?');
  }
  return svg;
}

function getTreeData() {
  if (window.currentTreeData) return window.currentTreeData;
  if (window.decisionTree?.data) return window.decisionTree.data;
  if (window.hRoot?.data) return window.hRoot.data;

  alert('No se encontr√≥ la data del √°rbol. Exp√≥n una variable global con el √°rbol.');
  return null;
}

// =====================
// Export CLOZE config
// =====================

//////////////////////////////////////////////////////
globalThis.CLOZE_CONFIG = globalThis.CLOZE_CONFIG || {};
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btnClozeConfig');
  if (btn) btn.addEventListener('click', openClozeModal);
});

document.addEventListener('DOMContentLoaded', () => {
  const btnExportTheory = document.getElementById('btnExportTheory');
  if (btnExportTheory) {
    btnExportTheory.addEventListener('click', () => {
      openTheoryModal();
    });
  }
  const btnAdd = document.getElementById('btnTheoryAddQuestion');
  if (btnAdd) {
    btnAdd.addEventListener('click', () => {
      THEORY_QUESTIONS.push({
        id: THEORY_NEXT_ID++,
        text: ''
      });
      renderTheoryQuestions();
    });
  }
  const btnExportXml = document.getElementById('btnTheoryExportXml');
  if (btnExportXml) {
    btnExportXml.addEventListener('click', () => {
      exportTheoryQuestionsXmlFromModel();
    });
  }
});

//////////////////////////////////////////////////////

// I18N
const CLOZE_I18N = {
  en: {
    title: "ID3 Tree Exercise",
    leadFull: `Fill in the missing values using the decision tree and data table below. 
      Use the <strong>ID3</strong> algorithm 
      (<a href="%%LINK_ID3%%" target="_blank" rel="noopener">what is ID3?</a>) 
      and the <strong>Information Gain</strong> criterion 
      (<a href="%%LINK_IG%%" target="_blank" rel="noopener">learn more</a>).`,
    exportedOn: "Exported on",
    generatedBy: "Generated by the Decision Tree ID3 tool",
    dataset: "Dataset",
    tree: "Decision tree",
    questions: "Cloze questions",
    questionsNote: "Answer using Moodle's Cloze format. Numerical answers accept the specified tolerance.",
    legendTitle: "Legend",
    legendNodeHeader: "<strong>Node header</strong> ‚Äî internal node/leaf title area (green).",
    legendNodeDetailsN: "number of training samples that reach this node.",
    legendNodeDetailsIG: "Information Gain computed at this node (criterion for ID3).",
    legendAttrName: "<strong>Attribute name</strong> ‚Äî attribute used to split at a node (blue band at the bottom of a node).",
    legendLeafLabel: "<strong>Label value</strong> ‚Äî class predicted at a leaf (yellow band at the bottom of a leaf).",
    legendBranches: "<strong>Branches & labels</strong> ‚Äî arrows connect parent‚Üíchild; the text along the arrow is the attribute<br>value that follows that branch.",
    igEntropy: "IG/Entropy",
    attribute: "Attribute",
    leafLabel: "Leaf label",
    at: "at",
    legendIdxNote: '<br><strong>Note:</strong> numbers in square brackets (e.g. [1], [2])<br>mark the positions that correspond to the Cloze questions below.',

  },
  es: {
    title: "Ejercicio √Årbol ID3",
    leadFull: `Rellena los valores que faltan usando el √°rbol de decisi√≥n y la tabla de datos. 
      Usa el algoritmo <strong>ID3</strong> 
      (<a href="%%LINK_ID3%%" target="_blank" rel="noopener">¬øqu√© es ID3?</a>) 
      y el criterio de <strong>Ganancia de Informaci√≥n</strong> 
      (<a href="%%LINK_IG%%" target="_blank" rel="noopener">m√°s info</a>).`,
    exportedOn: "Exportado el",
    generatedBy: "Generado con la herramienta Decision Tree ID3",
    dataset: "Conjunto de datos",
    tree: "√Årbol de decisi√≥n",
    questions: "Preguntas Cloze",
    questionsNote: "Responde usando el formato Cloze de Moodle. Las respuestas num√©ricas aceptan la tolerancia indicada.",
    legendTitle: "Leyenda",
    legendNodeHeader: "<strong>Cabecera del nodo</strong> ‚Äî zona de t√≠tulo del nodo/hoja (verde).",
    legendNodeDetailsN: "n√∫mero de ejemplos de entrenamiento que alcanzan este nodo.",
    legendNodeDetailsIG: "Information Gain calculado en este nodo (criterio de ID3).",
    legendAttrName: "<strong>Nombre del atributo</strong> ‚Äî atributo usado para dividir en un nodo (banda azul inferior en nodos).",
    legendLeafLabel: "<strong>Valor de etiqueta</strong> ‚Äî clase predicha en una hoja (banda amarilla inferior en hojas).",
    legendBranches: "<strong>Ramas y etiquetas</strong> ‚Äî las flechas conectan padre‚Üíhijo; el texto a lo largo de la flecha es el<br>valor del atributo que sigue esa rama.",
    igEntropy: "IG/Entrop√≠a",
    attribute: "Atributo",
    leafLabel: "Etiqueta de hoja",
    at: "en",
    legendIdxNote_es: '<br><strong>Nota:</strong> los n√∫meros entre corchetes (p. ej. [1], [2])<br>indican las posiciones que corresponden a las preguntas Cloze siguientes.',
  }
};

function getLang() {
  return localStorage.getItem('cloze.lang') || 'en';
}

function setLang(lang) {
  localStorage.setItem('cloze.lang', lang);
}

function t(key, lang = getLang()) {
  return (CLOZE_I18N[lang] && CLOZE_I18N[lang][key]) || CLOZE_I18N.en[key] || key;
}

// HELPERS
function buildTreeLegendHtml(lang = 'en') {
  // icono cuadradito (20x20 fijo para evitar defaults de 300x150 en Moodle)
  const sq = (fill) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
          viewBox="0 0 20 20"
          style="flex:none;display:inline-block;vertical-align:middle;">
        <rect x="1" y="1" width="18" height="18" rx="2" ry="2"
              fill="${fill}" stroke="#9ca3af"></rect>
     </svg>`;

  const t = (k) => ({
    legend:         { en:'Legend', es:'Leyenda' }[lang],
    nodeHeader:     { en:'Node header', es:'Cabecera de nodo' }[lang],
    nodeHeaderTxt:  { en:'‚Äî internal node/leaf title area (green).',
                      es:'‚Äî √°rea de t√≠tulo del nodo/hoja (verde).' }[lang],
    nTxt:           { en:'number of training samples that reach this node.',
                      es:'n√∫mero de muestras que llegan al nodo.' }[lang],
    igTxt:          { en:'Information Gain computed at this node (criterion for ID3).',
                      es:'Information Gain en este nodo (criterio de ID3).' }[lang],
    attrName:       { en:'Attribute name',
                      es:'Nombre del atributo' }[lang],
    attrNameTxt:    { en:'‚Äî attribute used to split at a node (blue band at the bottom of a node).',
                      es:'‚Äî atributo usado para dividir (banda azul en la base del nodo).' }[lang],
    labelValue:     { en:'Label value', es:'Valor de la etiqueta' }[lang],
    labelValueTxt:  { en:'‚Äî class predicted at a leaf (yellow band at the bottom of a leaf).',
                      es:'‚Äî clase predicha en la hoja (banda amarilla en la base).' }[lang],
    branches:       { en:'Branches & labels',
                      es:'Ramas y etiquetas' }[lang],
    branchesTxt:    { en:'‚Äî arrows connect parent‚Üíchild; the text along the arrow is the attribute value that follows that branch.',
                      es:'‚Äî las flechas conectan padre‚Üíhijo; el texto en la flecha es el valor del atributo que sigue esa rama.' }[lang],
    note:           { en:'Note', es:'Nota' }[lang],
    noteTxt:        { en:'numbers in square brackets (e.g. [1], [2]) mark the positions that correspond to the Cloze questions below.',
                      es:'los n√∫meros entre corchetes (p. ej. [1], [2]) indican las posiciones que corresponden a las preguntas Cloze.' }[lang],
  }[k]);

  // cada fila usa margin en vez de gap (m√°s fiable en Moodle)
  const row = (icon, html) =>
    `<div style="display:flex;align-items:center;margin:6px 0;">
       ${icon}
       <div style="margin:0 0 0 10px;line-height:1.25;">
         ${html}
       </div>
     </div>`;

  return `
<div id="legend" style="margin-top:12px;line-height:1.25;">
  <h3 style="font-size:1.05rem;margin:.25rem 0 .5rem;">${t('legend')}</h3>

  ${row(sq('#A8E6A3'), `<span style="font-weight:600;">${t('nodeHeader')}</span> ${t('nodeHeaderTxt')}`)}

  ${row(sq('#ffffff'), `
      <div style="margin:0;">
        <span style="font-weight:600;"><code>n</code></span>: ${t('nTxt')}
      </div>
      <div style="margin:0;">
        <span style="font-weight:600;"><code>IG</code></span>: ${t('igTxt')}
      </div>
  `)}

  ${row(sq('#ADD8E6'), `<span style="font-weight:600;">${t('attrName')}</span> ${t('attrNameTxt')}`)}

  ${row(sq('#FFDD77'), `<span style="font-weight:600;">${t('labelValue')}</span> ${t('labelValueTxt')}`)}

  ${row(
    // flechita simple hecha en SVG con tama√±o fijo
    `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="20"
          viewBox="0 0 24 20" style="flex:none;display:inline-block;vertical-align:middle;">
        <path d="M2 10 H18" stroke="#111" stroke-width="1.2" />
        <path d="M18 7 L22 10 L18 13" fill="none" stroke="#111" stroke-width="1.2"/>
     </svg>`,
    `<span style="font-weight:600;">${t('branches')}</span> ${t('branchesTxt')}`
  )}

  <div style="margin-top:8px;">
    <span style="font-weight:600;">${t('note')}:</span> ${t('noteTxt')}
  </div>
</div>`;
}

function stripTags(html) {
  return String(html || '').replace(/<[^>]+>/g, '');
}

function buildTreeLegendSvg_DOM(lang) {
  const svgNS = "http://www.w3.org/2000/svg";

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("xmlns", svgNS);
  svg.setAttribute("width", "900");           // un poco m√°s ancho
  svg.setAttribute("height", "260");
  svg.setAttribute("viewBox", "0 0 900 260");

  const FONT = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, Helvetica, sans-serif';

  function addText(x, y, text, opts={}) {
    const el = document.createElementNS(svgNS,'text');
    el.setAttribute('x', x);
    el.setAttribute('y', y);
    el.setAttribute('font-family', FONT);
    el.setAttribute('font-size', opts.size || 14);
    el.setAttribute('fill', opts.fill || "#111");
    if (opts.weight) el.setAttribute('font-weight', opts.weight);
    el.textContent = stripTags(text);
    svg.appendChild(el);
    return el;
  }

  // L√≠nea con posible <strong>‚Ä¶</strong> y sin/ con <br>
  function addLegendLine(x, y, html, opts={}) {
    // soportar saltos de l√≠nea con <br> en la traducci√≥n
    const lines = String(html).split(/<br\s*\/?>/i);
    const dy = opts.lineHeight || 18;
    lines.forEach((line, idx) => {
      const textEl = document.createElementNS(svgNS,'text');
      textEl.setAttribute('x', x);
      textEl.setAttribute('y', y + idx * dy);
      textEl.setAttribute('font-family', FONT);
      textEl.setAttribute('font-size', opts.size || 14);
      textEl.setAttribute('fill', opts.fill || "#111");
      svg.appendChild(textEl);

      // separar en pre / <strong>inner</strong> / post
      const m = /<strong>(.*?)<\/strong>/i.exec(line);
      let pre = '', strong = '', post = '';
      if (m) {
        pre   = line.slice(0, m.index);
        strong = m[1];
        post  = line.slice(m.index + m[0].length);
      } else {
        pre = line;
      }

      function appendSpan(txt, weight) {
        if (!txt) return;
        const tspan = document.createElementNS(svgNS,'tspan');
        if (weight) tspan.setAttribute('font-weight', weight);
        tspan.textContent = stripTags(txt);
        textEl.appendChild(tspan);
      }

      appendSpan(pre,    null);
      appendSpan(strong, '600');   // üëà aqu√≠ va la negrita
      appendSpan(post,   null);
    });
  }

  function addBox(x,y,fill) {
    const r = document.createElementNS(svgNS,'rect');
    r.setAttribute('x', x);
    r.setAttribute('y', y);
    r.setAttribute('width', 14);
    r.setAttribute('height', 14);
    r.setAttribute('rx', 2);
    r.setAttribute('ry', 2);
    r.setAttribute('fill', fill);
    r.setAttribute('stroke', '#777');
    svg.appendChild(r);
  }

  let y = 22;

  // T√≠tulo
  addText(20, y, t('legendTitle', lang), { size: 17, weight: 600 });
  y += 28;

  // Node header  "<strong>Node header</strong> ‚Äî ‚Ä¶"
  addBox(20, y-12, "#A8E6A3");
  addLegendLine(50, y, t('legendNodeHeader', lang));
  y += 24;

  // n / IG (lo dejamos en negrita todo con weight en addText)
  addBox(20, y-12, "#ffffff");
  addText(50, y,  'n: ' + t('legendNodeDetailsN', lang), { weight: 600 });
  y += 20;
  addText(50, y, 'IG: ' + t('legendNodeDetailsIG', lang), { weight: 600 });
  y += 24;

  // Attribute name "<strong>Attribute name</strong> ‚Äî ‚Ä¶"
  addBox(20, y-12, "#ADD8E6");
  addLegendLine(50, y, t('legendAttrName', lang));
  y += 24;

  // Leaf label "<strong>Label value</strong> ‚Äî ‚Ä¶"
  addBox(20, y-12, "#FFDD77");
  addLegendLine(50, y, t('legendLeafLabel', lang));
  y += 24;

  // Flecha + "Branches & labels"
  const defs = document.createElementNS(svgNS,'defs');
  const marker = document.createElementNS(svgNS,'marker');
  marker.setAttribute('id','legHead');
  marker.setAttribute('markerWidth','6');
  marker.setAttribute('markerHeight','6');
  marker.setAttribute('refX','3');
  marker.setAttribute('refY','3');
  marker.setAttribute('orient','auto');
  const path = document.createElementNS(svgNS,'path');
  path.setAttribute('d','M0 0 L6 3 L0 6 Z');
  path.setAttribute('fill','#444');
  marker.appendChild(path);
  defs.appendChild(marker);
  svg.appendChild(defs);

  const arrow = document.createElementNS(svgNS,'path');
  arrow.setAttribute('d', `M20 ${y} L 40 ${y-6}`);
  arrow.setAttribute('stroke','#444');
  arrow.setAttribute('stroke-width','1.2');
  arrow.setAttribute('fill','none');
  arrow.setAttribute('marker-end','url(#legHead)');
  svg.appendChild(arrow);

  addLegendLine(50, y, t('legendBranches', lang));
  y += 22;

  // Nota: PERMITE <br> en la traducci√≥n para partir l√≠neas largas
  // Ejemplo en ingl√©s:
  // "<strong>Note:</strong> numbers in square brackets (e.g. [1], [2])<br>
  // mark the positions that correspond to the Cloze questions below."
  addLegendLine(50, y, t('legendIdxNote', lang), {
    size: 13,
    fill: "#555",
    lineHeight: 18
  });

  return svg;
}

function xmlEscape(str) {
  return String(str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function extractBodyInnerHtml(html) {
  const m = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
  return m ? m[1].trim() : html;
}

// Construir pistas:
function buildFeedbackHtml(targetsSorted, lang) {
  const isEs = (lang === 'es');

  const intro = isEs
    ? 'Algunas pistas para revisar tus respuestas:'
    : 'Some hints to review your answers:';

  function hintFor(t) {
    const idx = t.index;
    const node = t.nodeId;
    if (t.key === 'attr') {
      return isEs
        ? `[${idx}] (atributo en ${node}): elige el atributo que maximiza la ganancia de informaci√≥n (IG) entre los atributos disponibles en ese nodo.`
        : `[${idx}] (attribute at ${node}): choose the attribute with the highest Information Gain (IG) among the available attributes at that node.`;
    }
    if (t.key === 'leaf') {
      return isEs
        ? `[${idx}] (etiqueta de hoja en ${node}): la etiqueta suele ser la clase mayoritaria de los ejemplos que llegan a esa hoja.`
        : `[${idx}] (leaf label at ${node}): the label is usually the majority class among the training samples that reach that leaf.`;
    }
    // metric (IG/Entropy)
    return isEs
      ? `[${idx}] (IG/Entrop√≠a en ${node}): calcula la entrop√≠a de la distribuci√≥n de clases en ese nodo y aplica la f√≥rmula de ganancia de informaci√≥n.`
      : `[${idx}] (IG/Entropy at ${node}): compute the entropy of the class distribution at that node and apply the information gain formula.`;
  }

  const lis = targetsSorted.map(t => `<li>${hintFor(t)}</li>`).join('\n');

  return `
<p>${intro}</p>
<ul>
${lis}
</ul>
`.trim();
}

function childIdToBranchSymbolId(childId) {
  const m = /^([nl])(\d+)$/.exec(childId);
  if (!m) return null;
  return 'branch' + (m[1] === 'n' ? 'n' : 'l') + m[2];
}

function getBranchTextFromDefs(symId) {
  const svg = getTreeSvg();
  if (!svg || !symId) return '';
  const sym = svg.querySelector(`symbol#${CSS.escape(symId)}`);
  if (!sym) return '';
  // En tus SVGs suele estar en <tspan id="branchValue‚Ä¶">, pero cubrimos fallback
  const tspan = sym.querySelector('tspan[id^="branchValue"]') ||
                sym.querySelector('tspan') ||
                sym.querySelector('textPath') ||
                sym.querySelector('text');
  return (tspan?.textContent || '').trim();
}

function getDatasetColumns() {
  try {
    const ths = Array.from(document.querySelectorAll('#dataTable th'));
    if (ths.length) {
      const headers = ths
        .map(th => th.textContent.trim())
        .filter(Boolean)              
        .filter(h => h !== '#');     
      const unique = [...new Set(headers)];
      return unique;
    }
    return null;
  } catch {
    return null;
  }
}

function getAnchorsFromSvg() {
  const svg = getTreeSvg();
  if (!svg) return {};
  const anchors = {};

  function addAnchor(useEl, isLeaf){
    if (!isUseVisible(useEl)) return;

    // id l√≥gico: n1, l2...
    const id = useEl.id;               // p.ej. useNode3 / useLeaf2
    const num = id.replaceAll(/\D+/g,'');
    const logicalId = (isLeaf ? 'l' : 'n') + num;

    // guarda la referencia al <use> (importante)
    const el = useEl;
    try { el.setAttribute('data-node-id', logicalId); } catch(_){}

    const x = +useEl.getAttribute('x') || 0;
    const y = +useEl.getAttribute('y') || 0;
    const w = +(useEl.getAttribute('width')  || 82);
    const h = +(useEl.getAttribute('height') || (isLeaf ? 133 : 92));

    const anchorAttr   = { x: x + w/2, y: y + (isLeaf ? h*0.40 : h*0.55), w: 110, h: 24 };
    const anchorMetric = { x: x + w/2, y: y + h*0.80, w:  60, h: 20 };

    // font-size aprox
    let fs = 12;
    const g = useEl.closest('g');
    if (g) {
      const t = g.querySelector('text');
      if (t) {
        const cfs = getComputedStyle(t).fontSize;
        if (cfs) fs = parseFloat(cfs);
      }
    }
    anchorAttr.fs = fs;
    anchorMetric.fs = fs - 2;

    // ‚úÖ ahora s√≠ guardamos el elemento
    anchors[logicalId] = { el, type: (isLeaf?'leaf':'node'), attr: anchorAttr, metric: anchorMetric };
  }

  svg.querySelectorAll('use[id^="useNode"]').forEach(u => addAnchor(u,false));
  svg.querySelectorAll('use[id^="useLeaf"]').forEach(u => addAnchor(u,true));

  return anchors;
}

function flattenTree(root){
  const out = [];
  (function dfs(n){
    if(!n) return;
    out.push(n);
    (n.children||[]).forEach(dfs);
  })(root);
  return out;
}

function isUseVisible(useEl) {
  if (!useEl) return false;
  const uvis = getComputedStyle(useEl).display !== 'none' && getComputedStyle(useEl).visibility !== 'hidden';
  const g = useEl.closest('g');
  const gvis = !g || (getComputedStyle(g).display !== 'none' && getComputedStyle(g).visibility !== 'hidden');
  return uvis && gvis;
}

function replaceTextByIndexInClone(outSvg, nodeId, key, index) {
  if (!outSvg || !nodeId) return;

  let anchor = outSvg.querySelector(`[data-node-id="${CSS.escape(nodeId)}"]`);
  if (!anchor) {
    anchor = outSvg.getElementById(nodeId);
  }

  let symbolEl = null;
  if (anchor) {
    const useEl = anchor.tagName.toLowerCase() === 'use' ? anchor : getUseInsideAnchor(anchor);
    const symIdFromUse = getUseHrefId(useEl);
    if (symIdFromUse) symbolEl = outSvg.getElementById(symIdFromUse);
  }

  if (!symbolEl) {
    const convId = nodeIdToSymbolId(nodeId); // nodeN | leafN
    if (convId) symbolEl = outSvg.getElementById(convId);
  }

  if (!symbolEl) return; 

  const nodeType = guessSymbolType(symbolEl); // 'node' | 'leaf'
  if (!nodeType) return;

  setSymbolTextForKey(symbolEl, nodeType, key, index);
}

function nodeIdToSymbolId(nodeId) {
  const mNode = /^n(\d+)$/.exec(nodeId);
  if (mNode) return `node${mNode[1]}`;
  const mLeaf = /^l(\d+)$/.exec(nodeId);
  if (mLeaf) return `leaf${mLeaf[1]}`;
  return null;
}

function getUseHrefId(useEl) {
  const href = useEl?.getAttribute('href') || useEl?.getAttribute('xlink:href');
  return href ? href.replace(/^#/, '') : null;
}

function getUseInsideAnchor(anchorEl) {
  return anchorEl?.querySelector('use[href], use[xlink\\:href]') || null;
}

function buildEdgeLabelLookup() {
  const root = getTreeData();
  const map = {};

  const pick = (parent, child) => {
    const candidates = [
      child.edgeLabel, child.branch, child.value, child.branchValue,
      child.edge, child.matchValue, child.splitValue,
      child.condition?.value, child.condition?.label,
      // a veces el label vive en el objeto del enlace
      child.linkLabel, child.labelOnEdge
    ];
    const txt = candidates.find(v => typeof v === 'string' && v.trim().length) || '';
    return String(txt).trim();
  };

  (function walk(n){
    if (!n || !n.children) return;
    n.children.forEach(ch => {
      map[`${n.id}|${ch.id}`] = pick(n, ch);
      walk(ch);
    });
  })(root);

  return map; // key: "parentId|childId" -> label string
}

function guessSymbolType(symbolEl) {
  const id = symbolEl?.getAttribute('id') || '';
  if (id.startsWith('node')) return 'node';
  if (id.startsWith('leaf')) return 'leaf';
  return null;
}

function setSymbolTextForKey(symbolEl, nodeType, key, indexStr) {
  if (!symbolEl || !nodeType) return;
  const targetId =
    nodeType === 'node'
      ? (key === 'metric' ? 'nodeIG' : 'nodeAttribute')
      : (key === 'metric' ? 'leafIG' : 'leafLabel');

  const vb = (symbolEl.getAttribute('viewBox') || '0 0 82 92').split(/\s+/).map(Number);
  const w = vb[2] || 82, h = vb[3] || 92;

  const texts = symbolEl.querySelectorAll(`:scope text#${CSS.escape(targetId)}`);
  if (!texts.length) return;

  texts.forEach(t => { t.textContent = `[${indexStr}]`; t.setAttribute('font-size','14'); t.setAttribute('text-anchor', 'middle'); t.setAttribute('x', (w/2).toString());});
}

function pickTextElementForKey(anchorEl, key) {
  const texts = anchorEl.querySelectorAll('text');
  if (!texts.length) return null;

  const bb = anchorEl.getBBox();
  const targetY =
    key === 'metric' ? (bb.y + bb.height * 0.63) : (bb.y + bb.height - 6);

  let best = null;
  let bestScore = Infinity;

  texts.forEach(t => {
    try {
      const tb = t.getBBox();
      const dx = Math.abs((tb.x + tb.width/2) - (bb.x + bb.width/2));
      const dy = Math.abs((tb.y + tb.height) - targetY);
      const score = dy * 1.0 + dx * 0.15; 
      if (score < bestScore) {
        bestScore = score;
        best = t;
      }
    } catch(_) {}
  });

  return best;
}

function svgToPngDataUrl(svgEl) {
  return new Promise((resolve, reject) => {
    try {
      if (!svgEl.getAttribute('xmlns')) svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      if (!svgEl.getAttribute('xmlns:xlink')) svgEl.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

      enforceSvgFont(svgEl, "Arial, Helvetica, sans-serif");

      const vb = (svgEl.getAttribute('viewBox') || '0 0 800 600').split(/\s+/).map(Number);
      const [, , vbW = 800, vbH = 600] = vb;

      const xml = new XMLSerializer().serializeToString(svgEl);
      const svg64 = btoa(unescape(encodeURIComponent(xml)));
      const url = `data:image/svg+xml;base64,${svg64}`;

      const img = new Image();
      img.onload = async function() {
        const dpr = window.devicePixelRatio || 1;
        const canvas = document.createElement('canvas');
        canvas.width = Math.ceil(vbW * dpr);
        canvas.height = Math.ceil(vbH * dpr);
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.drawImage(img, 0, 0, vbW, vbH);
        resolve(canvas.toDataURL('image/png'));
      };
      img.onerror = reject;
      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}

function replaceNodeText(outSvg, anchorEl, key, index) {
  if (!anchorEl) return;
  const textEl = pickTextElementForKey(anchorEl, key);
  if (!textEl) return;

  textEl.textContent = `[${index}]`;

  if (!textEl.getAttribute('font-weight')) textEl.setAttribute('font-weight', '600');
  if (!textEl.getAttribute('font-size'))   textEl.setAttribute('font-size',  '14');
}

function findAnchorInClone(nodeId, outSvg) { // by id
  if (!nodeId || !outSvg) return null;
  const byData = outSvg.querySelector(`[data-node-id="${CSS.escape(nodeId)}"]`);
  if (byData) return byData;
  const byId = outSvg.getElementById(nodeId);
  if (byId) return byId;
  return outSvg.querySelector(`g[id*="${CSS.escape(nodeId)}"]`);
}

function svgToDataUrl(svgEl) {
  if (!svgEl.getAttribute('xmlns')) {
    svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  }
  if (!svgEl.getAttribute('xmlns:xlink')) {
    svgEl.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  }

  svgEl.removeAttribute('width');
  svgEl.removeAttribute('height');
  svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');

  const xml = `<?xml version="1.0" encoding="UTF-8"?>\n` +
              new XMLSerializer().serializeToString(svgEl);

  const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
  return `data:image/svg+xml;base64,${svg64}`;
}

function ensurePreviewBox() {
  let box = document.getElementById('clozePreview');
  if (!box) return null;
  // forzamos <div>
  if (box.tagName.toLowerCase() === 'img') {
    const d = document.createElement('div');
    d.id = 'clozePreview';
    box.replaceWith(d);
    box = d;
  }
  box.style.display = 'flex';
  box.style.alignItems = 'center';
  box.style.justifyContent = 'center';
  box.style.overflow = 'hidden';
  box.style.background = '#fff';
  box.style.border = '1px solid #e5e7eb';
  box.style.borderRadius = '8px';
  box.style.padding = '6px';
  // altura = la de la tabla (con m√≠nimo)
  const table = document.querySelector('#clozeModal table');
  const h = Math.max(260, Math.ceil(table?.getBoundingClientRect().height || 0));
  box.style.height = h + 'px';
  return box;
}

function getVisibleNodeRects() {
  const anchors = getAnchorsFromSvg(); // {id:{el,type:'node'|'leaf'|'branch'...}}
  const rects = [];
  Object.entries(anchors).forEach(([id, a]) => {
    if (!a?.el || (a.type !== 'node' && a.type !== 'leaf')) return;
    const cs = window.getComputedStyle(a.el);
    if (cs.display === 'none' || cs.visibility === 'hidden') return;
    const useEl = a.el.tagName.toLowerCase() === 'use'
      ? a.el
      : a.el.querySelector('use[href], use[xlink\\:href]');
    if (!useEl) return;
    const b = useEl.getBBox();
    if (!b || (!b.width && !b.height)) return;
    const href = useEl.getAttribute('href') || useEl.getAttribute('xlink:href');
    const symId = href ? href.replace(/^#/, '') : null;
    rects.push({
      nodeId: id, type: a.type, symId,
      x: b.x, y: b.y, w: b.width, h: b.height,
      cx: b.x + b.width/2, cy: b.y + b.height/2
    });
  });
  return rects;
}

function getVisibleEdges(visibleIds) {
  const root = getTreeData();                 // tu funci√≥n
  const vis = new Set(visibleIds);            // solo los del step
  const edges = [];
  (function walk(n){
    if (!n || !n.children) return;
    n.children.forEach(ch => {
      if (vis.has(n.id) && vis.has(ch.id))
        edges.push([n.id, ch.id]);
      walk(ch);
    });
  })(root);
  return edges;
}

function cloneNeededDefs(srcSvg, symIds) {
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const srcDefs = srcSvg.querySelector('defs');
  if (srcDefs) {
    // markers
    srcDefs.querySelectorAll('marker').forEach(m => {
      const mk = m.cloneNode(true);
      mk.setAttribute('markerUnits', 'userSpaceOnUse');
      mk.setAttribute('markerWidth',  '2');  // ‚Üê antes 5/6
      mk.setAttribute('markerHeight', '2');
      if (!mk.hasAttribute('refX')) mk.setAttribute('refX','5');
      if (!mk.hasAttribute('refY')) mk.setAttribute('refY','5');
      defs.appendChild(mk);
    });
    // symbols de nodos visibles (como ya hac√≠as)
    const set = new Set(symIds);
    srcDefs.querySelectorAll('symbol').forEach(s => {
      if (set.has(s.id)) defs.appendChild(s.cloneNode(true));
    });
  }
  return defs;
}

function rebuildPreviewSvg(highlightId = null) {
  const box = ensurePreviewBox();
  if (!box) return;

  const src = getTreeSvg();
  if (!src) return;

  const nodes = getVisibleNodeRects();
  if (!nodes.length) { box.innerHTML = ''; return; }

  // bounding de nodos + padding adaptativo
  let minX = Math.min(...nodes.map(n=>n.x)),
      minY = Math.min(...nodes.map(n=>n.y)),
      maxX = Math.max(...nodes.map(n=>n.x+n.w)),
      maxY = Math.max(...nodes.map(n=>n.y+n.h));
  const spanW = maxX - minX, spanH = maxY - minY;
  const diag = Math.hypot(spanW, spanH);
  const N = nodes.length;
  // menos padding para √°rboles peque√±os
  const k = (N <= 2) ? 0.03 : (N <= 6 ? 0.06 : 0.09);
  const minPad = (N <= 2) ? 6 : (N <= 6 ? 20 : 36);
  const maxPad = (N <= 2) ? 40 : (N <= 6 ? 90 : 160);
  const PAD = Math.max(minPad, Math.min(maxPad, Math.round(diag * k)));

  minX -= PAD; minY -= PAD; maxX += PAD; maxY += PAD;

  // tama√±o de la caja destino (interior del preview)
  const dstW = Math.max(100, Math.floor(box.clientWidth  - 12)); // ‚âà padding visual
  const dstH = Math.max(100, Math.floor(box.clientHeight - 12));

  // escala para encajar bbox en caja (llenar en el eje limitante)
  const scale = Math.min(dstW / (maxX-minX), dstH / (maxY-minY));
  const offX  = (dstW - (maxX-minX)*scale)/2;
  const offY  = (dstH - (maxY-minY)*scale)/2;

  // SVG vac√≠o destino
  const out = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  out.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  out.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  out.setAttribute('viewBox', `0 0 ${dstW} ${dstH}`);
  out.style.width = '100%';
  out.style.height = '100%';
  out.setAttribute('preserveAspectRatio', 'xMidYMid meet');

  // defs: markers + symbols usados por los nodos visibles
  const defs = cloneNeededDefs(src, nodes.map(n=>n.symId).filter(Boolean));
  out.appendChild(defs);

  // ramas: l√≠neas simples desde centro-bajo del padre a centro-alto del hijo
  const id2node = Object.fromEntries(nodes.map(n => [n.nodeId, n]));
  const edges = getVisibleEdges(nodes.map(n => n.nodeId));

  const gEdges = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gEdges.setAttribute('fill', 'none');
  gEdges.setAttribute('stroke', '#444');
  gEdges.setAttribute('stroke-width', '1.2');
  gEdges.setAttribute('vector-effect', 'non-scaling-stroke');
  gEdges.setAttribute('marker-end', 'url(#arrowMarker)');

  const gEdgeLabels = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gEdgeLabels.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
  gEdgeLabels.setAttribute('font-size', '10');
  gEdgeLabels.setAttribute('fill', '#111');

  edges.forEach(([p,c], i) => {
    const P = id2node[p], C = id2node[c];
    if (!P || !C) return;
    const x1 = offX + (P.cx - minX)*scale;
    const y1 = offY + (P.y + P.h - minY)*scale; // borde inferior del padre
    const x2 = offX + (C.cx - minX)*scale;
    const y2 = offY + (C.y - minY)*scale;       // borde superior del hijo
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;
    const margin = Math.max(6, Math.min(12, len * 0.06));  // 6‚Äì12 px
    const sx = x1 + ux * margin, sy = y1 + uy * margin;
    const ex = x2 - ux * margin, ey = y2 - uy * margin;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', `M${sx} ${sy} L${ex} ${ey}`);
    gEdges.appendChild(path);

    
    // garantizamos texto LTR: si la diagonal va de derecha->izquierda, invertimos
    let xA = sx, yA = sy, xB = ex, yB = ey;
    if (xB < xA) { const tx = xA, ty = yA; xA = xB; yA = yB; xB = tx; yB = ty; }

    const labPathId = `edgeLabelPath_${i}`;
    const labPath = document.createElementNS('http://www.w3.org/2000/svg','path');
    labPath.setAttribute('id', labPathId);
    labPath.setAttribute('d', `M${xA} ${yA} L${xB} ${yB}`);
    labPath.setAttribute('fill', 'none');
    labPath.setAttribute('stroke', 'none'); // oculto
    gEdgeLabels.appendChild(labPath);

    // 3) texto sobre el textPath (centrado en el tramo diagonal)
    const symId  = childIdToBranchSymbolId(c);     // branchl3 / branchn2 ...
    const label  = getBranchTextFromDefs(symId);   // p.ej. "myope", "reduced"...

    if (label) {
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      const tp   = document.createElementNS('http://www.w3.org/2000/svg','textPath');
      tp.setAttribute('href', `#${labPathId}`);
      tp.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${labPathId}`);
      tp.setAttribute('startOffset', '50%');
      tp.setAttribute('text-anchor', 'middle');

      // halo blanco para legibilidad + ligera separaci√≥n de la l√≠nea
      text.style.paintOrder = 'stroke';
      text.style.stroke = '#fff';
      text.style.strokeWidth = '2';
      const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
      tspan.setAttribute('dy', '-0.4em'); // despega un poco del trazo
      tspan.textContent = label;

      tp.appendChild(tspan);
      text.appendChild(tp);
      gEdgeLabels.appendChild(text);
    }

  });
  out.appendChild(gEdges);
  out.appendChild(gEdgeLabels);

  // nodos: <use> de sus symbols, posicionados y escalados
  const gNodes = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  nodes.forEach(n => {
    if (!n.symId) return;
    const use = document.createElementNS('http://www.w3.org/2000/svg','use');
    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${n.symId}`);
    use.setAttribute('x',  (offX + (n.x - minX)*scale).toString());
    use.setAttribute('y',  (offY + (n.y - minY)*scale).toString());
    use.setAttribute('width',  (n.w*scale).toString());
    use.setAttribute('height', (n.h*scale).toString());
    // para poder hacer highlight r√°pido
    use.setAttribute('data-node-id', n.nodeId);
    gNodes.appendChild(use);
  });
  out.appendChild(gNodes);

  // highlight opcional
  if (highlightId && id2node[highlightId]) {
    const n = id2node[highlightId];
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', offX + (n.x - minX)*scale - 3);
    r.setAttribute('y', offY + (n.y - minY)*scale - 3);
    r.setAttribute('width',  n.w*scale + 6);
    r.setAttribute('height', n.h*scale + 6);
    r.setAttribute('fill', 'none');
    r.setAttribute('stroke', '#2563eb');
    r.setAttribute('stroke-width', '3');
    r.setAttribute('rx', '6'); r.setAttribute('ry', '6');
    out.appendChild(r);
  }

  box.innerHTML = '';
  box.appendChild(out);
}

function getNodesBBoxWithDynamicPadding() {
  const anchors = getAnchorsFromSvg();
  const items = Object.values(anchors).filter(a => a?.el && (a.type === 'node' || a.type === 'leaf'));

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity, found=false;

  items.forEach(a => {
    const target = a.el.tagName.toLowerCase()==='use'
      ? a.el
      : (a.el.querySelector('use[href], use[xlink\\:href]') || a.el);
    try {
      const b = target.getBBox();
      if (b && (b.width || b.height)) {
        found = true;
        minX = Math.min(minX, b.x);
        minY = Math.min(minY, b.y);
        maxX = Math.max(maxX, b.x + b.width);
        maxY = Math.max(maxY, b.y + b.height);
      }
    } catch(_) {}
  });

  if (!found) {
    const src = getTreeSvg();
    const vb = (src.getAttribute('viewBox') || '0 0 800 600').split(/\s+/).map(Number);
    return { x: vb[0], y: vb[1], width: vb[2], height: vb[3], count: 0, pad: 0 };
  }

  const w = maxX - minX, h = maxY - minY;
  const diag = Math.hypot(w, h);
  const count = items.length;

  // Padding adaptativo:
  // 1‚Äì2 nodos: casi sin padding ‚Üí ¬°gran escala!
  // 3‚Äì6 nodos: moderado
  // 7+ nodos: como antes
  let k, minPad, maxPad;
  if (count <= 2) {
    k = 0.01; minPad = 0;  maxPad = 36;
  } else if (count <= 6) {
    k = 0.04; minPad = 24; maxPad = 100;
  } else {
    k = 0.08; minPad = 48; maxPad = 160;
  }

  const pad = Math.round(Math.max(minPad, Math.min(maxPad, diag * k)));

  return {
    x: minX - pad,
    y: minY - pad,
    width:  w + pad*2,
    height: h + pad*2,
    count,
    pad
  };
}

const updateClozePreview = (highlightId=null) => rebuildPreviewSvg(highlightId);

function fitPreviewHeightToTable() {
  const box = document.getElementById('clozePreview');
  const table = document.querySelector('#clozeModal table');
  if (!box || !table) return;
  box.style.height = Math.ceil(table.getBoundingClientRect().height) + 'px';
}

function buildDataTableSection(lang = getLang()) {
  // local fallbacks si por alguna raz√≥n no existe tablesExporter
  const _getTableRoot = (typeof getTableRoot === 'function') ? getTableRoot
                        : (which) => {
                            const id = which === 'data' ? 'dataTable' : 'valueTable';
                            const wrap = document.getElementById(id);
                            return wrap?.querySelector('table') || wrap?.firstElementChild || null;
                          };

  const _inlineAll = (typeof inlineAllStyles === 'function') ? inlineAllStyles
                    : (root) => {
                        const PROPS = ['font-family','font-size','font-weight','line-height','color',
                                       'background','background-color','padding','margin',
                                       'border','border-top','border-right','border-bottom','border-left',
                                       'border-collapse','border-spacing','text-align','vertical-align'];
                        const tw = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                        let el = root;
                        while (el) {
                          const cs = getComputedStyle(el);
                          const pairs = [];
                          for (const p of PROPS) {
                            const v = cs.getPropertyValue(p);
                            if (v && v !== 'normal' && v !== 'auto') pairs.push(`${p}:${v}`);
                          }
                          if (pairs.length) el.setAttribute('style', pairs.join(';'));
                          el = tw.nextNode();
                        }
                      };

  const _collectCss = (typeof collectCssForElement === 'function') ? collectCssForElement
                    : (root) => '<style>table{border-collapse:collapse}th,td{border:1px solid #bbb;padding:.25rem .5rem}</style>';

  const _vertRule = (typeof verticalDividerRule === 'function') ? verticalDividerRule
                   : () => '';

  const table = _getTableRoot('data');
  if (!table) return ''; // no dataset

  const clone = table.cloneNode(true);
  const caption = clone.querySelector('caption#dataTableCaption');
  if (caption) caption.remove();
  _inlineAll(clone);

  const sampleBodyCell = clone.querySelector('tbody td') || clone.querySelector('td');
  let bodyBg = '#ffffff', bodyFg = '#111111';
  if (sampleBodyCell) {
    const cs = sampleBodyCell.style; // ya est√° inlined
    bodyBg = cs.background || cs.backgroundColor || bodyBg;
    bodyFg = cs.color || bodyFg;
  }

  clone.querySelectorAll('thead th').forEach(th => {
    th.style.background = 'transparent';
    th.style.backgroundColor = 'transparent';
    th.style.backgroundImage = 'none';
    th.style.color = bodyFg;
    th.style.fontWeight = '600';
    //th.style.borderColor = "#c5c9ca"; 
  });

  // (opcional) quitar clases que puedan traer estilos de otros steps
  clone.querySelectorAll('[class]').forEach(el => {
    el.className = el.className
      .split(/\s+/)
      .filter(c => !/^step|^current|^rule|^highlight/i.test(c))
      .join(' ');
  });

  // asegurar colapso de bordes (por si acaso)
  const s = clone.getAttribute('style') || '';
  if (!/border-collapse/.test(s)) {
    clone.setAttribute('style', s + (s ? ';' : '') + 'border-collapse:collapse;border-spacing:0;');
  }

  const css = _collectCss(table) + (_vertRule(table) || '');

//   return `
// <section id="dataset" style="page-break-inside:avoid; margin-top:1rem;">
//   <h2 style="font-size:1.15rem;margin:0 0 .5rem;">Dataset</h2>
//   ${css}
//   ${clone.outerHTML}
// </section>`;

  return `
  <section id="dataset" style="page-break-inside:avoid; margin-top:1rem;">
    <h2 style="font-size:1.15rem;margin:0 0 .5rem;">${t('dataset', lang)}</h2>
    ${css}
    ${clone.outerHTML}
  </section>`;
}

function buildClozeExerciseHtml({ treeBlockHtml, questionsListHtml, datasetSectionHtml, lang = getLang() }) {
  const TODAY = new Date().toISOString().slice(0,10);
  return `<!DOCTYPE html>
<html lang="${lang}">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>${t('title', lang)}</title>
<style>
  :root { --fg:#111; --muted:#555; --line:#e5e7eb; }
  html,body { margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, Helvetica, sans-serif; color:var(--fg); }
  main { max-width: 920px; margin: 1.25rem auto; padding: 0 1rem 2rem; }
  h1 { font-size: 1.4rem; margin: 0 0 .5rem; }
  p.lead { margin:.25rem 0 1rem; color:var(--muted); }
  section { margin-top: 1rem; } figure { margin:.75rem 0; display:flex; justify-content:center; } figure>*{max-width:100%;height:auto;}
  .note{color:var(--muted);font-size:.95rem;} ul.cloze{margin:.5rem 0 0 1.25rem;} ul.cloze li{margin:.35rem 0;} hr{border:0;border-top:1px solid var(--line);margin:1rem 0;}
</style>
</head>
<body>
<main>
  <header>
    <h1>${t('title', lang)}</h1>
    <p class="lead">
      ${t('leadFull', lang)}
    </p>
  </header>

  ${datasetSectionHtml || ''}

  <section id="tree">
    <h2 style="font-size:1.15rem;margin:0 0 .5rem;">${t('tree', lang)}</h2>
    <figure>${treeBlockHtml}</figure>
  </section>

  <section id="questions">
    <h2 style="font-size:1.15rem;margin:1rem 0 .25rem;">${t('questions', lang)}</h2>
    ${questionsListHtml}
  </section>
  
  <hr><footer class="note">${t("generatedBy", lang)}. ${t('exportedOn', lang)} ${TODAY}.</footer>

</main>
</body>
</html>`;
}


// TABLE
function clozeClearRows() {
  const rowsEl = document.getElementById('clozeConfigRows');
  rowsEl.querySelectorAll('tr').forEach(tr => {
    // deseleccionar
    const inc = tr.querySelector('[data-role="include"]');
    if (inc) inc.checked = false;

    // reset tipo -> default de la fila
    const typeSel = tr.querySelector('[data-role="type"]');
    if (typeSel) {
      const def = tr.dataset.typeDefault || 'none';
      typeSel.value = def;
      typeSel.dispatchEvent(new Event('change'));
    }

    // limpiar answer/tol
    const ans = tr.querySelector('[data-role="answer"]');
    if (ans) ans.value = '';
    const tol = tr.querySelector('[data-role="tolerance"]');
    if (tol) { tol.value = ''; tol.disabled = (typeSel?.value !== 'numerical'); }
  });
  updateClozePreview();
}

function clozeAutofillRows() {
  const rowsEl = document.getElementById('clozeConfigRows');
  rowsEl.querySelectorAll('tr').forEach(tr => {
    const ans = tr.querySelector('[data-role="answer"]');
    if (ans && !String(ans.value ?? '').trim()) {
      ans.value = tr.dataset.ansDefault || '';
    }
    const typeSel = tr.querySelector('[data-role="type"]');
    if (typeSel && typeSel.value === 'numerical') {
      const tol = tr.querySelector('[data-role="tolerance"]');
      if (tol && !String(tol.value ?? '').trim()) {
        tol.value = tr.dataset.tolDefault || '0.01';
      }
    }
  });
  updateClozePreview();
}

function orderByPosition(ids, anchors) {
  return ids.sort((a, b) => {
    const A = anchors[a]?.el?.getBBox?.();
    const B = anchors[b]?.el?.getBBox?.();
    if (!A || !B) return 0;
    // prioridad: y, luego x
    if (Math.abs(A.y - B.y) > 2) return A.y - B.y;
    return A.x - B.x;
  });
}

function enforceSvgFont(svgEl, fontStack = "Arial, Helvetica, sans-serif") {
  svgEl.querySelectorAll('text').forEach(t => {
    t.setAttribute('font-family', fontStack);
  });

  const style = document.createElementNS('http://www.w3.org/2000/svg','style');
  style.setAttribute('type','text/css');
  style.textContent = `text { font-family: ${fontStack}; }`;

  const defs = svgEl.querySelector('defs');
  if (defs) defs.parentNode.insertBefore(style, defs.nextSibling);
  else svgEl.insertBefore(style, svgEl.firstChild);
}


// THEORY QUESTIONS
let THEORY_QUESTIONS = []; // {id, text}
let THEORY_NEXT_ID = 1;

function getCurrentStepLabel() {
  const el = document.getElementById('stepCount');
  if (!el) return 'X';
  const txt = el.textContent || el.innerText || '';
  const m = txt.match(/(\d+)/);
  return m ? m[1] : 'X';
}

function getDefaultTheoryQuestions(lang = getLang()) {
  const isEs = (lang === 'es');
  // De momento dejamos las preguntas en espa√±ol tal y como las ten√≠as.
  // Cada string es SOLO la parte "pregunta + Cloze", sin <p>.
  if (isEs) {
    return [
      '¬øCu√°l es el atributo con mayor entrop√≠a del conjunto de datos? {1:MULTICHOICE_S:%100%outlook#~%-33%temperature#~%-33%humidity#~%-33%windy#}',
      '¬øCu√°ntas instancias del conjunto de datos est√°n siendo tratadas en este paso del algoritmo de construcci√≥n del √°rbol? {1:NUMERICAL:%100%5:0#}',
      '¬øA qu√© nodo se corresponde la informaci√≥n de la tabla que contiene el c√°lculo de ganancia de informaci√≥n? {1:MULTICHOICE_S:%-33%Node 1#~%-33%Node 2#~%100%Node 3#~%-33%Leaf 1#~%-33%Leaf 2#~%-33%Leaf 3#}',
      '¬øCu√°ntos nodos hoja tendr√° la construcci√≥n final del √°rbol de decisi√≥n de ID3? {1:NUMERICAL:%100%5:0#}',
      '¬øQu√© atributos utilizar√° el √°rbol de decisi√≥n final construido? {1:MULTICHOICE_S:%100%outlook#~%-33%temperature#~%33%humidity#~%33%windy#}'
    ];
  } else {
    // Versi√≥n muy literal al ingl√©s (puedes afinar el texto):
    return [
      'Which attribute has the highest entropy in the dataset? {1:MULTICHOICE_S:%100%outlook#~%-33%temperature#~%-33%humidity#~%-33%windy#}',
      'How many instances are being considered at this step of the tree construction algorithm? {1:NUMERICAL:%100%5:0#}',
      'Which node corresponds to the information in the table that contains the information gain computation? {1:MULTICHOICE_S:%-33%Node 1#~%-33%Node 2#~%100%Node 3#~%-33%Leaf 1#~%-33%Leaf 2#~%-33%Leaf 3#}',
      'How many leaf nodes will the final ID3 decision tree have? {1:NUMERICAL:%100%5:0#}',
      'Which attributes will appear in the final ID3 decision tree? {1:MULTICHOICE_S:%100%outlook#~%-33%temperature#~%33%humidity#~%33%windy#}'
    ];
  }
}

function renderTheoryQuestions() {
  const container = document.getElementById('theoryQuestionsContainer');
  if (!container) return;
  container.innerHTML = '';

  const lang = getLang();
  const isEs = (lang === 'es');

  if (!THEORY_QUESTIONS.length) {
    const info = document.createElement('div');
    info.className = 'text-muted fst-italic';
    info.textContent = isEs
      ? 'Todav√≠a no hay preguntas. Pulsa "Add question" para crear una.'
      : 'No questions yet. Click "Add question" to create one.';
    container.appendChild(info);
    return;
  }

  THEORY_QUESTIONS.forEach((q, idx) => {
    const card = document.createElement('div');
    card.className = 'card';

    card.innerHTML = `
      <div class="card-header d-flex align-items-center justify-content-between">
        <span>${isEs ? 'Pregunta' : 'Question'} ${idx + 1}</span>
        <div class="btn-group btn-group-sm" role="group">
          <button class="btn btn-outline-secondary" data-role="duplicate"
                  title="${isEs ? 'Duplicar' : 'Duplicate'}">
            <i class="bi bi-files"></i>
          </button>
          <button class="btn btn-outline-danger" data-role="delete"
                  title="${isEs ? 'Eliminar' : 'Delete'}">
            <i class="bi bi-trash"></i>
          </button>
        </div>
      </div>
      <div class="card-body">
        <label class="form-label">
          ${isEs
            ? 'Texto de la pregunta (se permite sintaxis Cloze de Moodle):'
            : 'Question text (Moodle Cloze syntax is allowed):'}
        </label>

        <div class="btn-toolbar mb-2" role="toolbar" aria-label="Toolbar">
          <div class="btn-group btn-group-sm me-2" role="group">
            <button type="button" class="btn btn-outline-primary"
                    data-role="insert-tpl" data-tpl="short">
              ${isEs ? 'Insertar SHORTANSWER' : 'Insert SHORTANSWER'}
            </button>
            <button type="button" class="btn btn-outline-primary"
                    data-role="insert-tpl" data-tpl="numerical">
              ${isEs ? 'Insertar NUMERICAL' : 'Insert NUMERICAL'}
            </button>
            <button type="button" class="btn btn-outline-primary"
                    data-role="insert-tpl" data-tpl="multi">
              ${isEs ? 'Insertar MULTICHOICE' : 'Insert MULTICHOICE'}
            </button>
          </div>
          <div class="btn-group btn-group-sm" role="group">
            <button type="button" class="btn btn-outline-secondary"
                    data-role="preview">
              ${isEs ? 'Vista previa' : 'Preview'}
            </button>
          </div>
        </div>

        <textarea class="form-control" rows="3" data-role="text">${q.text}</textarea>
        <div class="mt-2 small text-muted border rounded p-2"
             data-role="preview-container"
             style="display:none;"></div>
      </div>
    `;

    const ta = card.querySelector('textarea[data-role="text"]');
    ta.style.backgroundColor = '#ededed';
    const previewBox = card.querySelector('[data-role="preview-container"]');

    ta.addEventListener('input', () => {
      q.text = ta.value;
      if (previewBox && previewBox.style.display !== 'none') {
        previewBox.innerHTML = buildClozePreviewHtmlFromText(ta.value);
      }
    });

    const btnDel = card.querySelector('button[data-role="delete"]');
    btnDel.addEventListener('click', () => {
      THEORY_QUESTIONS = THEORY_QUESTIONS.filter(obj => obj.id !== q.id);
      renderTheoryQuestions();
    });

    const btnDup = card.querySelector('button[data-role="duplicate"]');
    btnDup.addEventListener('click', () => {
      THEORY_QUESTIONS.splice(idx + 1, 0, {
        id: THEORY_NEXT_ID++,
        text: q.text
      });
      renderTheoryQuestions();
    });

    // Botones de plantillas
    card.querySelectorAll('button[data-role="insert-tpl"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const kind = btn.getAttribute('data-tpl');
        let snippet = '';

        if (kind === 'short') {
          snippet = '{1:SHORTANSWER:=respuesta_correcta}';
        } else if (kind === 'numerical') {
          snippet = '{1:NUMERICAL:=5:0.01}';
        } else if (kind === 'multi') {
          snippet = '{1:MULTICHOICE_S:%100%opcion_correcta#~%-33%opcion2#~%-33%opcion3#~%-33%opcion4#}';
        }

        if (!snippet) return;
        insertAtCursor(ta, snippet);
        q.text = ta.value;
      });
    });

    // Bot√≥n de preview
    const btnPreview = card.querySelector('button[data-role="preview"]');
    btnPreview.addEventListener('click', () => {
      const html = buildClozePreviewHtmlFromText(ta.value);
      if (html) {
        previewBox.innerHTML = html;
        previewBox.style.display = 'block';
      } else {
        previewBox.innerHTML = '';
        previewBox.style.display = 'none';
      }
    });

    container.appendChild(card);
  });
}

function htmlEscape(str) {
  return String(str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function renderClozeFragment(index, typeRaw, body) {
  const type = String(typeRaw || '').trim().toUpperCase();

  // MULTICHOICE ‚Üí dropdown
  if (type.startsWith('MULTICHOICE')) {
    const parts = String(body || '')
      .split('~')
      .map(p => p.trim())
      .filter(Boolean);

    const options = parts.map(p => {
      let label = p.replace(/^%[^%]*%/, ''); // quitar '%100%' etc.
      label = label.replace(/#/g, '').trim();
      return `<option>${htmlEscape(label || '...')}</option>`;
    }).join('');

    return `<select class="form-select form-select-sm d-inline-block" style="width:auto;min-width:120px;margin:0 .25rem;">${options}</select>`;
  }

  // NUMERICAL ‚Üí input number
  if (type.startsWith('NUMERICAL')) {
    return `<input type="number" class="form-control form-control-sm d-inline-block" style="width:90px;margin:0 .25rem;" placeholder="">`;
  }

  // SHORTANSWER ‚Üí input text
  if (type.startsWith('SHORTANSWER')) {
    return `<input type="text" class="form-control form-control-sm d-inline-block" style="width:140px;margin:0 .25rem;" placeholder="">`;
  }

  // fallback gen√©rico
  return `<span class="badge bg-secondary">Cloze</span>`;
}

function buildClozePreviewHtmlFromText(text) {
  const src = String(text || '');
  if (!src.trim()) return '';

  const re = /\{(\d+):([^:}]+):([^}]+)\}/g;
  let out = '';
  let last = 0;
  let m;

  while ((m = re.exec(src)) !== null) {
    const [full, idx, typeRaw, body] = m;
    if (m.index > last) {
      out += htmlEscape(src.slice(last, m.index));
    }
    out += renderClozeFragment(idx, typeRaw, body);
    last = m.index + full.length;
  }

  if (last < src.length) {
    out += htmlEscape(src.slice(last));
  }

  return out.replace(/\n/g, '<br>');
}

function insertAtCursor(textarea, snippet) {
  const el = textarea;
  const value = el.value || '';
  const selStart = el.selectionStart ?? value.length;
  const selEnd   = el.selectionEnd ?? selStart;

  const before = value.slice(0, selStart);
  const after  = value.slice(selEnd);

  el.value = before + snippet + after;

  const pos = selStart + snippet.length;
  el.focus();
  try {
    el.setSelectionRange(pos, pos);
  } catch (_) {
    // algunos navegadores pueden no soportarlo, no pasa nada
  }
}



// EXPORT
function exportClozeXmlWithConfig(CONFIG) {
  const lang = getLang();
  const svg = getTreeSvg();
  if (!svg) return;

  const anchors = getAnchorsFromSvg();

  // ---- recolectar objetivos habilitados ----
  const enabledTargets = [];
  Object.entries(CONFIG).forEach(([nodeId, perKey]) => {
    Object.entries(perKey).forEach(([key, cfg]) => {
      if (cfg?.enabled && cfg?.type && (cfg.type !== 'none')) {
        enabledTargets.push({ nodeId, key, cfg });
      }
    });
  });

  if (!enabledTargets.length) {
    alert(lang === 'es'
      ? 'No hay preguntas activadas en la tabla Cloze.'
      : 'There are no enabled Cloze questions in the table.');
    return;
  }

  // ---- orden por posici√≥n visual ----
  const inOrder = orderByPosition(
    [...new Set(enabledTargets.map(t => t.nodeId))],
    anchors
  );

  // ---- √≠ndices [1], [2]‚Ä¶ ----
  const perNodeIndices = {};
  let running = 1;
  inOrder.forEach(nid => {
    const keysWanted = (anchors[nid]?.type === 'node')
      ? ['metric', 'attr']
      : ['metric', 'leaf'];
    keysWanted.forEach(k => {
      const hit = enabledTargets.find(t => t.nodeId === nid && t.key === k);
      if (hit) {
        hit.index = running++;
        perNodeIndices[`${nid}__${k}`] = hit.index;
      }
    });
  });

  // ---- clonar SVG del √°rbol y meter [i] ----
  const outSvg = svg.cloneNode(true);
  if (!outSvg.getAttribute('xmlns')) outSvg.setAttribute('xmlns','http://www.w3.org/2000/svg');
  if (!outSvg.getAttribute('xmlns:xlink')) outSvg.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');

  enabledTargets.forEach(t => {
    replaceTextByIndexInClone(outSvg, t.nodeId, t.key, t.index);
  });

  // ---- Cloze strings (mismo que en HTML) ----
  function clozeFor(t) {
    const { type, answer, tol } = t.cfg;
    if (type === 'dropdown') {
      const cols = getDatasetColumns();
      const opts = [...cols];
      if (!opts.includes(answer)) opts.push(answer);
      const uniq = Array.from(new Set(opts));
      const incorrect = Math.max(uniq.length - 1, 0);
      const penaltyPct = (incorrect > 0) ? -(100 / incorrect) : 0;
      const penaltyStr = Number(penaltyPct.toFixed(2)).toString();
      const parts = uniq.map(v => (v === answer ? `~%100%${v}` : `~%${penaltyStr}%${v}`)).join(' ');
      return `{1:MULTICHOICE_S:${parts}}`;
    }
    if (type === 'numerical') {
      const tolNum = String(tol ?? '').trim() || '0';
      const ans = String(answer ?? '').trim() || '0';
      return `{1:NUMERICAL:=${ans}:${tolNum}}`;
    }
    const ans = (String(answer ?? '')).trim();
    return `{1:SHORTANSWER:=${ans}}`;
  }

  const targetsSorted = enabledTargets.slice().sort((a,b)=>a.index-b.index);

  function tfn(key){ return t(key, lang); }

  const bulletsHtml = `<ul class="cloze">
${targetsSorted.map(t => {
  const labelKey =
    (t.key === 'attr') ? 'attribute' :
    (t.key === 'leaf') ? 'leafLabel' : 'igEntropy';
  return `<li><strong>[${t.index}]</strong> ${tfn(labelKey)} ${tfn('at')} <code>${t.nodeId}</code>: ${clozeFor(t)}</li>`;
}).join('\n')}
</ul>`;

  // ---- legend SVG DOM -> PNG igual que en HTML ----
  const legendSvg = buildTreeLegendSvg_DOM(lang);

  Promise.all([
    svgToPngDataUrl(outSvg, 896, 896),
    svgToPngDataUrl(legendSvg, 900, 260)
  ]).then(([treePngDataUrl, legendPngDataUrl]) => {

    const treeBlockHtml = `
      <img alt="Decision tree" src="${treePngDataUrl}" style="max-width:100%;height:auto;">
      <img alt="Legend" src="${legendPngDataUrl}" style="max-width:100%;height:auto;margin-top:12px;">
    `;

    const datasetSectionHtml = buildDataTableSection(lang);

    // Reusamos tu builder de p√°gina completo y luego nos quedamos solo con el <body>
    let fullHtmlPage = buildClozeExerciseHtml({
      treeBlockHtml,
      questionsListHtml: bulletsHtml,
      datasetSectionHtml,
      lang
    });

    fullHtmlPage = fullHtmlPage
      .replace('%%LINK_ID3%%', 'https://admirable-ubu.github.io/decision-trees-simulator/applications/decision%20tree/index.html')
      .replace('%%LINK_IG%%',  'https://admirable-ubu.github.io/decision-trees-simulator/applications/decision%20tree/index.html');

    const questionHtml = extractBodyInnerHtml(fullHtmlPage);

    const feedbackHtml = buildFeedbackHtml(targetsSorted, lang);

    // ---- construcci√≥n del XML Moodle ----
    const title = (lang === 'es')
      ? 'Ejercicio ID3 ‚Äì √Årbol de decisi√≥n'
      : 'ID3 Tree Exercise';

    const penalty = '0.3333333'; // puedes hacerlo configurable si quieres

    const xml =
`<?xml version="1.0" encoding="UTF-8"?>
<quiz>
  <question type="cloze">
    <name>
      <text>${xmlEscape(title)}</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[
${questionHtml}
      ]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text><![CDATA[
${feedbackHtml}
      ]]></text>
    </generalfeedback>
    <penalty>${penalty}</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
  </question>
</quiz>`;

    const blob = new Blob([xml], { type: 'application/xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `id3-cloze-${lang}.xml`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

function exportClozeHtmlWithConfig(CONFIG) {
  const lang = getLang();

  const svg = getTreeSvg();
  if (!svg) return;

  const anchors = getAnchorsFromSvg();

  // ---- recolectar objetivos habilitados ----
  const enabledTargets = [];
  Object.entries(CONFIG).forEach(([nodeId, perKey]) => {
    Object.entries(perKey).forEach(([key, cfg]) => {
      if (cfg?.enabled && cfg?.type && (cfg.type !== 'none')) {
        enabledTargets.push({ nodeId, key, cfg });
      }
    });
  });

  // ---- orden por posici√≥n visual ----
  const inOrder = orderByPosition(
    [...new Set(enabledTargets.map(t => t.nodeId))],
    anchors
  );

  // ---- √≠ndices [1], [2]‚Ä¶ ----
  const perNodeIndices = {};
  let running = 1;
  inOrder.forEach(nid => {
    const keysWanted = (anchors[nid]?.type === 'node')
      ? ['metric', 'attr']
      : ['metric', 'leaf'];
    keysWanted.forEach(k => {
      const hit = enabledTargets.find(t => t.nodeId === nid && t.key === k);
      if (hit) {
        hit.index = running++;
        perNodeIndices[`${nid}__${k}`] = hit.index;
      }
    });
  });

  // ---- clonar SVG del arbol ----
  const outSvg = svg.cloneNode(true);
  if (!outSvg.getAttribute('xmlns')) outSvg.setAttribute('xmlns','http://www.w3.org/2000/svg');
  if (!outSvg.getAttribute('xmlns:xlink')) outSvg.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');

  // sustituir textos por [i]
  enabledTargets.forEach(t => {
    replaceTextByIndexInClone(outSvg, t.nodeId, t.key, t.index);
  });

  // ---- Cloze strings ----
  function clozeFor(t) {
    const { type, answer, tol } = t.cfg;
    if (type === 'dropdown') {
      const cols = getDatasetColumns();
      const opts = [...cols];
      if (!opts.includes(answer)) opts.push(answer);
      const uniq = Array.from(new Set(opts));

      const incorrect = Math.max(uniq.length - 1, 0);
      const penaltyPct = (incorrect > 0) ? -(100 / incorrect) : 0;
      const penaltyStr = Number(penaltyPct.toFixed(2)).toString();
      const parts = uniq.map(v => (v === answer ? `~%100%${v}` : `~%${penaltyStr}%${v}`)).join(' ');
      return `{1:MULTICHOICE_S:${parts}}`;
    }
    if (type === 'numerical') {
      const tolNum = String(tol ?? '').trim() || '0';
      const ans = String(answer ?? '').trim() || '0';
      return `{1:NUMERICAL:=${ans}:${tolNum}}`;
    }
    const ans = (String(answer ?? '')).trim();
    return `{1:SHORTANSWER:=${ans}}`;
  }

  const targetsSorted = enabledTargets.slice().sort((a,b)=>a.index-b.index);

  const bulletsHtml = `<ul class="cloze">
${targetsSorted.map(t => {
  const labelKey =
    (t.key === 'attr') ? 'attribute' :
    (t.key === 'leaf') ? 'leafLabel' : 'igEntropy';
  return `<li><strong>[${t.index}]</strong> ${tfn(labelKey)} ${tfn('at')} <code>${t.nodeId}</code>: ${clozeFor(t)}</li>`;
}).join('\n')}
</ul>`;

  function tfn(key){ return t(key, lang); }

  const legendSvg = buildTreeLegendSvg_DOM(lang); 

  Promise.all([
    svgToPngDataUrl(outSvg, 896, 896),
    svgToPngDataUrl(legendSvg, 720, 240)
  ]).then(([treePngDataUrl, legendPngDataUrl]) => {

    const treeBlockHtml = `
      <img alt="Decision tree" src="${treePngDataUrl}" style="max-width:100%;height:auto;">
      <img alt="Legend" src="${legendPngDataUrl}" style="max-width:100%;height:auto;margin-top:12px;">
    `;

    const datasetSectionHtml = buildDataTableSection(lang);

    let fullHtml = buildClozeExerciseHtml({
      treeBlockHtml,
      questionsListHtml: bulletsHtml,
      datasetSectionHtml,
      lang
    });

    fullHtml = fullHtml
      .replace('%%LINK_ID3%%', 'https://admirable-ubu.github.io/decision-trees-simulator/applications/decision%20tree/index.html')
      .replace('%%LINK_IG%%',  'https://admirable-ubu.github.io/decision-trees-simulator/applications/decision%20tree/index.html');

    const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `id3-cloze-${lang}.html`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

function openClozeModal(){

  function collectClozeConfigFromRows(rowsEl) {
    const cfg = {};
    rowsEl.querySelectorAll('tr').forEach(tr => {
      const code = tr.querySelector('td:first-child code')?.textContent;
      if (!code) return;
      const field = tr.children[1].textContent.trim();
      const key   = field.startsWith('Attribute') ? 'attr'
                : field.startsWith('Leaf')      ? 'leaf'
                : 'metric';
      const rid   = `${code}__${key}`;
      const enabled = tr.querySelector('#en_'+rid)?.checked;
      const type    = tr.querySelector('#ty_'+rid)?.value;
      const answer  = tr.querySelector('#ans_'+rid)?.value;
      const tol     = tr.querySelector('#tol_'+rid)?.value;

      if (!cfg[code]) cfg[code] = {};
      cfg[code][key] = { enabled, type, answer, tol };
    });
    return cfg;
  }

  updateClozePreview();

  const root = getTreeData();
  const anchors = getAnchorsFromSvg();

  if(!root || !Object.keys(anchors).length){
    alert('Could not find the tree/widths in the SVG. Is the current step drawn?');
    return;
  }
  const cols = getDatasetColumns(); // para dropdown atributo
  const rowsEl = document.getElementById('clozeConfigRows');
  rowsEl.innerHTML = '';

  const nodes = flattenTree(root);
  nodes.forEach(n => {
    const a = anchors[n.id];
    if(!a) return;  // nodo no visible en este step: no lo mostramos
    const targets = [];
    if (a.type === 'node') {
      targets.push({ key:'attr',   label:'Attribute',  typeDefault:'dropdown',  valDefault:(n.attribute||'') });
      targets.push({ key:'metric', label:'IG/Entropy', typeDefault:'numerical', valDefault:(n.nodeValues?.entropy!=null? Number(n.nodeValues.entropy).toFixed(2) : '') , tolDefault:'0.01'});
    } else {
      targets.push({ key:'leaf',   label:'Leaf label', typeDefault:'short',     valDefault:(n.label||'') });
      targets.push({ key:'metric', label:'IG/Entropy', typeDefault:'numerical', valDefault:(n.nodeValues?.entropy!=null? Number(n.nodeValues.entropy).toFixed(2) : '') , tolDefault:'0.01'});
    }

    targets.forEach(t => {
      const rid = `${n.id}__${t.key}`;
      const cfg = (window.CLOZE_CONFIG[n.id]?.[t.key]) || { enabled:false, type:t.typeDefault, answer:'', tol:t.tolDefault||'' };

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><code>${n.id}</code> <small class="text-muted">${a.type}</small></td>
        <td>${t.label}</td>
        <td><input type="checkbox" class="form-check-input" id="en_${rid}" ${cfg.enabled?'checked':''}></td>
        <td>
          <select class="form-select form-select-sm" id="ty_${rid}">
            <option value="short" ${cfg.type==='short'?'selected':''}>ShortAnswer</option>
            <option value="numerical" ${cfg.type==='numerical'?'selected':''}>Numerical</option>
            <option value="dropdown" ${cfg.type==='dropdown'?'selected':''} ${t.key!=='attr'?'disabled':''}>Dropdown (attribute)</option>
            <option value="none" ${cfg.type==='none'?'selected':''}>None</option>
          </select>
        </td>
        <td>
          ${
            (t.key==='attr')
              ? `<select class="form-select form-select-sm" id="ans_${rid}">
                   ${cols.map(c=>`<option value="${c}" ${c=== (cfg.answer||t.valDefault) ?'selected':''}>${c}</option>`).join('')}
                 </select>`
              : `<input id="ans_${rid}" class="form-control form-control-sm" value="${(cfg.answer??t.valDefault) ?? ''}" placeholder="answer...">`
          }
        </td>
        <td><input id="tol_${rid}" class="form-control form-control-sm" value="${(cfg.tol ?? t.tolDefault) || ''}" placeholder="e.g. 0.01" ${ (cfg.type||t.typeDefault)==='numerical'?'':'disabled'}></td>
      `;


      // metadatos y roles
      tr.dataset.nodeId = n.id;
      tr.dataset.key    = t.key;
      tr.dataset.typeDefault = t.typeDefault;
      tr.dataset.ansDefault  = t.valDefault || '';
      tr.dataset.tolDefault  = t.tolDefault || '';
      tr.querySelector(`#en_${rid}`).setAttribute('data-role','include');
      tr.querySelector(`#ty_${rid}`).setAttribute('data-role','type');
      tr.querySelector(`#ans_${rid}`).setAttribute('data-role','answer');
      const tolEl = tr.querySelector(`#tol_${rid}`); if (tolEl) tolEl.setAttribute('data-role','tolerance');

      rowsEl.appendChild(tr);

      // Cambios de tipo -> rehacer control de respuesta/habilitar tolerancia
      const typeSel = tr.querySelector(`#ty_${rid}`);
      const ansCell = tr.children[4];
      const tolInput = tr.querySelector(`#tol_${rid}`);

      function renderAnswerControl() {
        const t = typeSel.value;
        const prevVal = (tr.querySelector(`#ans_${rid}`)?.value || '');
        if (t === 'dropdown') {
          ansCell.innerHTML = `<select class="form-select form-select-sm" id="ans_${rid}" data-role="answer">
            ${getDatasetColumns().map(c => `<option value="${c}" ${c===prevVal?'selected':''}>${c}</option>`).join('')}
          </select>`;
          tolInput.value = ''; tolInput.disabled = true;
        } else if (t === 'numerical') {
          ansCell.innerHTML = `<input id="ans_${rid}" class="form-control form-control-sm" data-role="answer" value="${prevVal.replace(/[^0-9.,-]/g,'')}">`;
          tolInput.disabled = false;
          if (!tolInput.value) tolInput.value = tr.dataset.tolDefault || '0.01';
        } else { // short / none
          ansCell.innerHTML = `<input id="ans_${rid}" class="form-control form-control-sm" data-role="answer" value="${prevVal}">`;
          tolInput.value = ''; tolInput.disabled = true;
        }
      }
      typeSel.addEventListener('change', renderAnswerControl);
      renderAnswerControl();

      // Highlight en preview al pasar/seleccionar la fila
      tr.addEventListener('mouseenter', () => updateClozePreview(n.id));
      tr.addEventListener('mouseleave', () => updateClozePreview());
      tr.addEventListener('click',      () => updateClozePreview(n.id));
    });
  });

  // Botones de acci√≥n
  document.getElementById('btnClozeSelectAll').onclick = () => {
    document.querySelectorAll('#clozeConfigRows [data-role="include"]').forEach(c => c.checked = true);
  };
  document.getElementById('btnClozeClear').onclick = clozeClearRows;
  document.getElementById('btnClozeAutofill').onclick = clozeAutofillRows;

  // Selector de idioma en la cabecera del modal
  (function ensureLangSelector(){
    const header = document.querySelector('#clozeModal .modal-header') || document.querySelector('#clozeModal');
    if (!header) return;

    let box = document.getElementById('clozeLangBox');
    if (!box) {
      box = document.createElement('div');
      box.id = 'clozeLangBox';
      box.className = 'ms-auto d-flex align-items-center gap-2';
      box.style.gap = '8px';
      box.innerHTML = `
        <label for="clozeLangSel" class="form-label mb-0" style="font-weight:600;">Export language</label>
        <select id="clozeLangSel" class="form-select form-select-sm" style="width:auto;">
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
        </select>`;
      const closeBtn = header.querySelector('.btn-close');
      if (closeBtn) {
        header.insertBefore(box, closeBtn); 
      } else {
        header.appendChild(box);
      }
    }
    const sel = document.getElementById('clozeLangSel');
    sel.value = getLang();
    sel.onchange = () => setLang(sel.value);
  })();

  // Mostrar modal
  const modalEl = document.getElementById('clozeModal');
  const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);

  function onShown() {
    fitPreviewHeightToTable();  
    rebuildPreviewSvg()
    modalEl.removeEventListener('shown.bs.modal', onShown);
  }
  modalEl.addEventListener('shown.bs.modal', onShown);
  bsModal.show();

  // Export
  const btnHtml = document.getElementById('btnClozeExport');
  const btnXml  = document.getElementById('btnClozeExportXml');

  btnHtml.onclick = () => {
    CLOZE_CONFIG = collectClozeConfigFromRows(rowsEl);
    bsModal.hide();
    exportClozeHtmlWithConfig(CLOZE_CONFIG);
  };

  btnXml.onclick = () => {
    const cfg = collectClozeConfigFromRows(rowsEl);
    bsModal.hide();
    exportClozeXmlWithConfig(cfg);
  };
  
}

function exportTheoryQuestionsXmlFromModel() {
  const lang = getLang();
  const svg = getTreeSvg();
  if (!svg) {
    alert(lang === 'es'
      ? 'No se ha encontrado el √°rbol de decisi√≥n para exportar.'
      : 'No decision tree found to export.');
    return;
  }

  if (!THEORY_QUESTIONS.length) {
    alert(lang === 'es'
      ? 'No hay preguntas te√≥ricas definidas.'
      : 'There are no theory questions defined.');
    return;
  }

  const stepLabel = getCurrentStepLabel();

  // Clonar √°rbol y asegurar xmlns
  const treeClone = svg.cloneNode(true);
  if (!treeClone.getAttribute('xmlns')) {
    treeClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  }

  const legendSvgEl = buildTreeLegendSvg_DOM
    ? buildTreeLegendSvg_DOM(lang)
    : null;

  const datasetSectionHtml = (typeof buildDataTableSection === 'function')
    ? buildDataTableSection(lang)
    : '';

  const legendPromise = legendSvgEl
    ? svgToPngDataUrl(legendSvgEl, 900, 260)
    : Promise.resolve(null);

  Promise.all([
    svgToPngDataUrl(treeClone, 896, 896),
    legendPromise
  ]).then(([treePngUrl, legendPngUrl]) => {
    const treeFileName   = `tree_step${stepLabel}.png`;
    const legendFileName = `tree_legend_step${stepLabel}.png`;

    const treeBase64   = treePngUrl.split(',')[1];
    const legendBase64 = legendPngUrl ? legendPngUrl.split(',')[1] : null;

    // ----- construir HTML de la pregunta (enunciado + dataset + im√°genes + preguntas) -----
    const isEs = (lang === 'es');

    const introHtml = isEs
          ? `
    <p>En este ejercicio analizamos la construcci√≥n de un clasificador de √°rboles de decisi√≥n ID3 sobre el conjunto de datos actual. Este conjunto de datos contiene informaci√≥n tabular para tomar una decisi√≥n de clasificaci√≥n.</p>
    <p>En el siguiente gr√°fico se presenta un estado parcial (step ${stepLabel}) de los recursos de informaci√≥n que utiliza el algoritmo ID3 para la construcci√≥n del √°rbol de decisi√≥n. La entrada es la tabla de datos que se muestra a continuaci√≥n y en la √∫ltima columna est√° la clase a predecir. Para la construcci√≥n del √°rbol de decisi√≥n, se van creando los nodos aplicando el criterio de ganancia de informaci√≥n calculado con la entrop√≠a condicional (H).</p>
    `
          : `
    <p>In this exercise we analyse the construction of an ID3 decision tree classifier on the current dataset. The dataset contains tabular information used for a classification task.</p>
    <p>The following figure shows a partial state (step ${stepLabel}) of the information used by the ID3 algorithm to build the decision tree. The input is the data table below; the last column is the class to be predicted. Nodes are created by applying the Information Gain criterion based on conditional entropy (H).</p>
    `;

    const questionName = isEs
        ? `√Årbol cuestiones (step ${stepLabel})`
        : `Tree theory questions (step ${stepLabel})`;
    
    const titleHtml = `<h1>${escXml(questionName)}</h1>`;
    const questionsHtml = THEORY_QUESTIONS
    .map((q, i) => `<p><strong>${i + 1}.</strong> ${q.text}</p>`)
    .join('\n');
    
    const questionHtml =    
    ` ${titleHtml}\n${introHtml}
      ${datasetSectionHtml}

      <p><img src="@@PLUGINFILE@@/${treeFileName}" alt="ID3 decision tree, step ${stepLabel}" style="max-width:100%;height:auto;"></p>
      ${legendBase64 ? `<p><img src="@@PLUGINFILE@@/${legendFileName}" alt="Decision tree legend" style="max-width:100%;height:auto;"></p>` : ''}

      <p>${isEs ? 'Contesta las siguientes preguntas:' : 'Answer the following questions:'}</p>
      ${questionsHtml}
      `.trim();

    const feedbackHtml = isEs
      ? `<p>Recuerda que la ganancia de informaci√≥n se calcula a partir de la entrop√≠a condicional y que el algoritmo ID3 selecciona siempre el atributo con mayor IG en cada paso. F√≠jate en la tabla de IG/entrop√≠as y en cu√°ntas instancias llegan a cada nodo.</p>`
      : `<p>Remember that Information Gain is computed from conditional entropy and that ID3 always selects the attribute with the highest IG at each step. Pay attention to the IG/entropy table and how many instances reach each node.</p>`;

    function escXml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    let filesXml = `
      <file name="${treeFileName}" path="/" encoding="base64">${treeBase64}</file>`;
    if (legendBase64) {
      filesXml += `
      <file name="${legendFileName}" path="/" encoding="base64">${legendBase64}</file>`;
    }

    const penalty = '0.3333333';

    const xml =
`<?xml version="1.0" encoding="UTF-8"?>
<quiz>
  <question type="cloze">
    <name>
      <text>${escXml(questionName)}</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[${questionHtml}]]></text>${filesXml}
    </questiontext>
    <generalfeedback format="html">
      <text><![CDATA[${feedbackHtml}]]></text>
    </generalfeedback>
    <penalty>${penalty}</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
  </question>
</quiz>`;

    const blob = new Blob([xml], { type: 'text/xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `id3-theory-step${stepLabel}-${lang}.xml`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

function openTheoryModal() {
  const lang = getLang();

  // Igual patr√≥n que en el CLOZE modal: insertar selector en la cabecera
  (function ensureTheoryLangSelector() {
    const header = document.querySelector('#theoryModal .modal-header') || document.getElementById('theoryModal');
    if (!header) return;

    let box = document.getElementById('theoryLangBox');
    if (!box) {
      box = document.createElement('div');
      box.id = 'theoryLangBox';
      box.className = 'ms-auto d-flex align-items-center';
      box.style.gap = '8px';
      box.innerHTML = `
        <label for="theoryLangSel" class="form-label mb-0" style="font-weight:600;">Export language</label>
        <select id="theoryLangSel" class="form-select form-select-sm" style="width:auto;">
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
        </select>
      `;
      const closeBtn = header.querySelector('.btn-close');
      if (closeBtn) {
        header.insertBefore(box, closeBtn);
      } else {
        header.appendChild(box);
      }
    }

    const sel = document.getElementById('theoryLangSel');
    if (sel) {
      sel.value = lang;
      sel.onchange = () => {
        setLang(sel.value);
        // No regeneramos las preguntas aqu√≠ para no pisar cambios del usuario
      };
    }
  })();

  if (!THEORY_QUESTIONS.length) {
    // Primera vez: inicializamos con la plantilla por defecto (depende de idioma)
    const defaults = getDefaultTheoryQuestions(lang);
    THEORY_QUESTIONS = defaults.map(txt => ({ id: THEORY_NEXT_ID++, text: txt }));
    
  }

  renderTheoryQuestions();

  const modalEl = document.getElementById('theoryModal');
  const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);
  bsModal.show();
}







